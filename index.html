<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Clash Royale Idle Game</title>
  <link rel="icon" type="image/png" href="img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.cdnfonts.com/css/supercell-magic" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Supercell Magic';
      src: url('fonts/SupercellMagicRegular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    body { 
      font-family: 'Supercell Magic', Arial, sans-serif; 
      background: #2e3d53; 
      color: #fff; 
      margin: 0; 
      padding: 24px; 
      touch-action: manipulation; /* Prevent double-tap zoom on most browsers */
    }
    h1 {
      font-family: 'Supercell Magic', 'Arial Black', Arial, sans-serif;
      font-size: 1.7em;
      letter-spacing: 2px;
      color: #ffe066;
      text-shadow: 2px 2px 0 #2e3d53, 4px 4px 0 #b8860b;
      margin-bottom: 16px;
    }
    h2 {
  font-size: 1.1em;
  margin-bottom: 10px;
}
    .section,
    .section *:not(h1) {
      font-family: 'Supercell Magic', Arial, sans-serif !important;
    }
    button {
  margin: 4px;
  padding: 10px 22px;
  font-size: 1.1em;
  font-family: 'Supercell Magic', Arial, sans-serif;
  background: linear-gradient(180deg, #ffe066 0%, #ffb300 100%);
  color: #2e3d53;
  border: 3px solid #fffbe7;
  border-radius: 12px;
  box-shadow: 0 4px #b8860b, 0 2px 8px #0006;
  cursor: pointer;
  transition: transform 0.08s, box-shadow 0.08s, background 0.2s;
  text-shadow: 1px 1px 0 #fffbe7, 2px 2px 0 #b8860b;
  letter-spacing: 1px;
  position: relative;
}
button:active {
  transform: translateY(2px) scale(0.97);
  box-shadow: 0 2px #b8860b;
  background: linear-gradient(180deg, #ffd700 0%, #ff9800 100%);
}
button:hover {
  background: linear-gradient(180deg, #fffbe7 0%, #ffe066 100%);
  box-shadow: 0 6px #b8860b, 0 4px 12px #0008;
}
    .troop-controls { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .upgrade-section { background: #22304a; padding: 16px; border-radius: 8px; }
    .upgrade-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}
.upgrade-label {
  min-width: 120px;
  font-size: 1.1em;
  font-weight: bold;
  margin-bottom: 2px;
}
.upgrade-row button {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 1.1em;
  padding: 8px 16px;
}
.upgrade-row img {
  margin-left: 2px;
}
.info-icon {
  width: 20px;
  height: 20px;
  vertical-align: middle;
  margin-left: 8px;
  cursor: pointer;
  filter: brightness(1.2);
  transition: filter 0.2s;
}

.info-icon:hover {
  filter: brightness(1.5);
}

.popup {
  position: fixed;
  padding: 16px;
  background: #22304a;
  border: 3px solid #ffe066;
  border-radius: 12px;
  color: #fff;
  box-shadow: 0 4px 12px #0008;
  max-width: 280px;
  z-index: 100;
}
.upgrade-arena {
  background: #22304a;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 16px;
  border: 2px solid #ffe066;
}

.upgrade-arena h3 {
  color: #ffe066;
  margin-top: 0;
}

#arenaUpgradeRequirements {
  margin: 12px 0;
  line-height: 1.5;
}

/* Add this to your existing styles */
.button-group {
  display: flex;
  gap: 8px;
  align-items: center;
}

.button-group button:last-child {
  font-size: 0.9em;
  padding: 8px 12px;
  background: linear-gradient(180deg, #ffd700 0%, #ff9800 100%);
}
.troop-slider-container {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  padding: 8px;
  background: #1a2332;
  border-radius: 8px;
}

.troop-slider {
  width: 200px;
  height: 8px;
  background: #2e3d53;
  border-radius: 4px;
  outline: none;
  -webkit-appearance: none;
}

.troop-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: #ffe066;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #b8860b;
}

.troop-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: #ffe066;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #b8860b;
}

.troop-info {
  min-width: 120px;
  font-weight: bold;
}

.troop-count {
  min-width: 60px;
  text-align: center;
  font-weight: bold;
  color: #ffe066;
}

@keyframes slideIn {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes goldPulse {
  0% { transform: scale(1); color: #ffe066; }
  50% { transform: scale(1.15); color: #ffd700; text-shadow: 0 0 10px #ffd700; }
  100% { transform: scale(1); color: #ffe066; }
}

@keyframes levelUpGlow {
  0% { box-shadow: 0 0 5px #4CAF50; }
  50% { box-shadow: 0 0 20px #4CAF50, 0 0 30px #4CAF50; }
  100% { box-shadow: 0 0 5px #4CAF50; }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
  20%, 40%, 60%, 80% { transform: translateX(2px); }
}

@keyframes coinFlip {
  0% { transform: rotateY(0deg); }
  50% { transform: rotateY(180deg); }
  100% { transform: rotateY(0deg); }
}

.gold-earned {
  animation: goldPulse 0.6s ease-in-out;
}

.level-up {
  animation: levelUpGlow 1s ease-in-out 3;
}

.battle-lost {
  animation: shake 0.5s ease-in-out;
}

.coin-icon {
  animation: coinFlip 0.8s ease-in-out;
}

/* Enhanced button feedback */
button:active {
  transform: translateY(3px) scale(0.95);
  animation: none;
}

button.success {
  background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);
  animation: levelUpGlow 0.3s ease-out;
}

/* New styles for enhanced feedback */
@keyframes bigNumberPop {
  0% { transform: scale(0.5) translateY(0); opacity: 1; }
  50% { transform: scale(1.2) translateY(-20px); opacity: 1; }
  100% { transform: scale(1) translateY(-50px); opacity: 0; }
}

.strategy-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}

.strategy-option {
  background: #1a2332;
  border: 2px solid #2e3d53;
  border-radius: 12px;
  padding: 16px;
  text-align: center;
  transition: all 0.3s ease;
}

.strategy-option:hover {
  border-color: #ffe066;
  transform: translateY(-2px);
}

.strategy-option.active {
  border-color: #4CAF50;
  background: rgba(76, 175, 80, 0.1);
}

.strategy-option h4 {
  margin: 0 0 8px 0;
  color: #ffe066;
}

.strategy-option p {
  margin: 8px 0 16px 0;
  font-size: 0.9em;
  line-height: 1.4;
}

.meta-section {
  background: linear-gradient(145deg, #2d1b3d, #3d2b4d);
  border: 3px solid #9C27B0;
  border-radius: 16px;
  margin-top: 20px;
}

.meta-upgrades {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
}

.meta-upgrade {
  background: rgba(0,0,0,0.4);
  padding: 16px;
  border-radius: 12px;
  border: 2px solid #9C27B0;
  text-align: center;
}

.meta-upgrade h4 {
  color: #E1BEE7;
  margin-top: 0;
}

.meta-upgrade button {
  background: linear-gradient(180deg, #9C27B0 0%, #673AB7 100%);
  color: white;
}
  </style>
</head>
<body>
  <h1>Clash Royale Idle Game</h1>
  <div class="section">
    <h2>Goblin Stadium</h2>
    <div class="upgrade-arena" style="display: none;">
  <h3>Arena Upgrade Available!</h3>
  <p id="arenaUpgradeRequirements"></p>
  <button id="upgradeArenaBtn">Upgrade Arena</button>
</div>
    <p>Trophies: <span id="trophies">0</span></p>
    <p>Gold: <span id="gold">0</span></p>
    <p><span id="goldPerSec">0</span> gold/sec</p>
    <button id="mineGoldBtn">Mine Gold (+5)</button>
    <button id="battleBtn">Battle! (Cost: 500 gold)</button>
  </div>
  <div class="section">
    <h3>Deploy Troops for Battle
      <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, 'Increase win percentage by 0.1% per troop deployed. If battle is lost, lose 30% of troops deployed.')" style="margin-left: 8px;">
    </h3>
    <div id="troopList"></div>
    <p>Win Chance: <span id="winChance">50</span>%</p>
  </div>
  <div class="section upgrade-section">
    <h3>Troops & Upgrades</h3>
    <div class="upgrade-row">
      <div class="upgrade-label">
        Elixir Collector
        <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, 'Increases gold generation by 1 gold/sec')">
      </div>
      <div class="button-group">
        <button id="buyElixirBtn">
          50
          <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
        </button>
        <button id="buyElixirBtn10x">
          500
          <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
          x10
        </button>
      </div>
      <span>Elixir Collectors: <span id="elixirCount">0</span></span>
    </div>
    <div class="upgrade-row">
      <div class="upgrade-label">
        Goblins
        <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, 'Increases gold mined by 5%')">
      </div>
      <div class="button-group">
        <button id="buyGoblinBtn">
          100
          <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
        </button>
        <button id="buyGoblinBtn10x">
          1000
          <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
          x10
        </button>
      </div>
      <span>Goblins: <span id="goblinCount">0</span></span>
    </div>
  </div>
  <div class="section">
  <h3>Battle Strategy
    <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, 'Choose your battle approach. Each strategy affects battle cost, trophy gains, and troop losses differently.')" style="margin-left: 8px;">
  </h3>
  <div class="strategy-container">
    <div class="strategy-option" data-strategy="aggressive">
      <h4>üó°Ô∏è Aggressive</h4>
      <p>-20% Battle Cost<br>+20% Trophy Gain<br>+30% Troop Loss</p>
      <button onclick="setStrategy('aggressive')">Select</button>
    </div>
    <div class="strategy-option" data-strategy="balanced">
      <h4>‚öñÔ∏è Balanced</h4>
      <p>Normal Battle Cost<br>Normal Trophy Gain<br>Normal Troop Loss</p>
      <button onclick="setStrategy('balanced')">Select</button>
    </div>
    <div class="strategy-option" data-strategy="defensive">
      <h4>üõ°Ô∏è Defensive</h4>
      <p>+20% Battle Cost<br>-20% Trophy Gain<br>-30% Troop Loss</p>
      <button onclick="setStrategy('defensive')">Select</button>
    </div>
  </div>
  <p>Current Strategy: <span id="currentStrategy">Balanced</span></p>
</div>
  <div class="section meta-section" id="metaSection">
  <h3>üåü Eternal Upgrades
    <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, 'Permanent upgrades that persist even through prestige! These bonuses are forever.')" style="margin-left: 8px;">
  </h3>
  <div class="meta-upgrades">
    <div class="meta-upgrade">
      <h4>Golden Touch</h4>
      <p>+5% gold generation forever</p>
      <p>Level: <span id="goldenTouchLevel">0</span>/10</p>
      <button id="buyGoldenTouch">1,000,000 Gold</button>
    </div>
    <div class="meta-upgrade">
      <h4>Battle Master</h4>
      <p>+2% win chance forever</p>
      <p>Level: <span id="battleMasterLevel">0</span>/20</p>
      <button id="buyBattleMaster">2,500,000 Gold</button>
    </div>
    <div class="meta-upgrade">
      <h4>Efficiency Expert</h4>
      <p>-5% all upgrade costs forever</p>
      <p>Level: <span id="efficiencyLevel">0</span>/10</p>
      <button id="buyEfficiency">5,000,000 Gold</button>
    </div>
    <div class="meta-upgrade">
      <h4>Trophy Magnet</h4>
      <p>+10% trophy gains forever</p>
      <p>Level: <span id="trophyMagnetLevel">0</span>/5</p>
      <button id="buyTrophyMagnet">10,000,000 Gold</button>
    </div>
  </div>
</div>
  <script>
// Move these to the TOP of your script, before DOMContentLoaded
let trophies = 0;
let gold = 0;
let goldPerSec = 0;
let mineGoldBase = 5;
let goblins = 0;
let elixirCollectors = 0;
let skeletons = 0;
let criticalHitChance = 0;
let battleCost = 500;
let chestFindChance = 0;
let defeatAvoidanceChance = 0;
let instantWinChance = 0;
let trophyGainBonus = 0;
let trophyLossReduction = 0;
let goldHoardChance = 0;
let passiveGoldMultiplier = 1;
let battleInProgress = false;
let activePopup = null;
let currentStrategy = 'balanced';

// Troop deployment
let troopTypes = ["Goblins"];
let troopOwned = { 
  Goblins: 0, 
  Skeletons: 0, 
  Barbarians: 0, 
  Wizards: 0, 
  Valkyrie: 0, 
  'Mini Pekka': 0, 
  Knights: 0, 
  'Ice Golem': 0, 
  'Dart Goblin': 0, 
  'Hog Riders': 0 
};

let deployedTroops = { 
  Goblins: 0, 
  Skeletons: 0, 
  Barbarians: 0, 
  Wizards: 0, 
  Valkyrie: 0, 
  'Mini Pekka': 0, 
  Knights: 0, 
  'Ice Golem': 0, 
  'Dart Goblin': 0, 
  'Hog Riders': 0 
};

let unlockedTroops = ["Goblins"];
let currentArena = 0;

const ARENAS = [
  { name: "Goblin Stadium", trophies: 0, cost: 0, troops: [], unlocks: null },
  { name: "Bone Pit", trophies: 300, cost: 5000, troops: [{type: "Goblins", required: 100}], unlocks: "Skeletons" },
  { name: "Barbarian Bowl", trophies: 600, cost: 10000, troops: [{type: "Skeletons", required: 100}], unlocks: "Barbarians" },
  { name: "Spell Valley", trophies: 1000, cost: 20000, troops: [{type: "Barbarians", required: 100}], unlocks: "Wizards" },
  { name: "Builder's Workshop", trophies: 1300, cost: 35000, troops: [{type: "Wizards", required: 100}], unlocks: "Valkyrie" },
  { name: "Pekka's Playhouse", trophies: 1600, cost: 50000, troops: [{type: "Valkyrie", required: 100}], unlocks: "Mini Pekka" },
  { name: "Royal Arena", trophies: 2000, cost: 75000, troops: [{type: "Mini Pekka", required: 100}], unlocks: "Knights" },
  { name: "Frozen Peak", trophies: 2300, cost: 100000, troops: [{type: "Knights", required: 100}], unlocks: "Ice Golem" },
  { name: "Jungle Arena", trophies: 2600, cost: 150000, troops: [{type: "Ice Golem", required: 100}], unlocks: "Dart Goblin" },
  { name: "Hog Mountain", trophies: 3000, cost: 200000, troops: [{type: "Dart Goblin", required: 100}], unlocks: "Hog Riders" }
];

// Move this OUTSIDE and BEFORE the DOMContentLoaded event listener
function showInfo(button, description) {
  // Remove any existing popup
  if (activePopup) {
    activePopup.remove();
    activePopup = null;
  }

  // Create popup
  const popup = document.createElement('div');
  popup.className = 'popup';
  popup.textContent = description;
  document.body.appendChild(popup);
  activePopup = popup;

  // Position popup much higher above the button
  const buttonRect = button.getBoundingClientRect();
  popup.style.display = 'block';
  popup.style.left = buttonRect.left + 'px';
  popup.style.top = (buttonRect.top - 50) + 'px';

  // Close popup when clicking outside
  const closePopup = (e) => {
    if (!popup.contains(e.target) && e.target !== button) {
      popup.remove();
      activePopup = null;
      document.removeEventListener('click', closePopup);
    }
  };
  
  // Delay adding click listener to prevent immediate closure
  setTimeout(() => {
    document.addEventListener('click', closePopup);
  }, 0);
}

window.addEventListener('DOMContentLoaded', function() {
  // DOM elements
  const trophiesSpan = document.getElementById('trophies');
  const goldSpan = document.getElementById('gold');
  const goldPerSecSpan = document.getElementById('goldPerSec');
  const mineGoldBtn = document.getElementById('mineGoldBtn');
  const battleBtn = document.getElementById('battleBtn');
  const winChanceSpan = document.getElementById('winChance');
  const troopListDiv = document.getElementById('troopList');
  const buyElixirBtn = document.getElementById('buyElixirBtn');
  const elixirCountSpan = document.getElementById('elixirCount');
  const buyGoblinBtn = document.getElementById('buyGoblinBtn');
  const goblinCountSpan = document.getElementById('goblinCount');
  // ... any other DOM elements ...

  // Now you can safely use mineGoldBtn and others:
  mineGoldBtn.addEventListener('click', () => {
    let bonus = 1 + goblins * 0.05;
    let value = mineGoldBase * bonus;
    
    // Check for Skeleton critical hit (0.2% per skeleton)
    let isCritical = Math.random() * 100 < criticalHitChance;
    
    if (isCritical) {
      value *= 2;
      // Show enhanced critical hit text
      const btnRect = mineGoldBtn.getBoundingClientRect();
      const critText = document.createElement('span');
      critText.textContent = 'üíÄ CRITICAL HIT! üíÄ';
      critText.style.cssText = `
        position: absolute;
        left: ${btnRect.left}px;
        top: ${btnRect.top - 30}px;
        color: #ff4444;
        font-weight: bold;
        font-size: 1.4em;
        text-shadow: 2px 2px 0 #000;
        pointer-events: none;
        z-index: 1000;
        animation: bigNumberPop 2s ease-out forwards;
      `;
      document.body.appendChild(critText);
      setTimeout(() => critText.remove(), 2000);
      
      // Add screen shake effect
      document.body.style.animation = 'shake 0.5s ease-in-out';
      setTimeout(() => {
        document.body.style.animation = '';
      }, 500);
    }
    
    gold += value;
    updateDisplay();

    // Enhanced floating gold text
    const btnRect = mineGoldBtn.getBoundingClientRect();
    const floatText = document.createElement('span');
    floatText.textContent = `+${value.toFixed(2)}`;
    floatText.style.cssText = `
      position: absolute;
      left: ${btnRect.left + Math.random() * btnRect.width * 0.6}px;
      top: ${btnRect.top + Math.random() * btnRect.height * 0.3}px;
      font-family: 'Supercell Magic', Arial, sans-serif;
      font-size: ${isCritical ? '1.6em' : '1.2em'};
      font-weight: bold;
      color: ${isCritical ? '#ff4444' : '#ffe066'};
      text-shadow: 1px 1px 0 #2e3d53, 2px 2px 0 #b8860b;
      pointer-events: none;
      opacity: 1;
      transition: transform 1s cubic-bezier(.4,2,.6,1), opacity 1s;
      z-index: 999;
    `;

    document.body.appendChild(floatText);

    setTimeout(() => {
      floatText.style.transform = `translateY(-48px) scale(${isCritical ? '1.5' : '1.2'})`;
      floatText.style.opacity = '0';
    }, 10);

    setTimeout(() => floatText.remove(), 1100);
  });
  
  // Prevent double-tap zoom on iOS/Safari, but allow rapid button taps
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function(event) {
    const now = Date.now();
    // Only prevent if not a button or input
    if (
      now - lastTouchEnd <= 300 &&
      !(event.target.closest('button, input, [role="button"]'))
    ) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, false);

  // Troop deployment
  let troopTypes = ["Goblins"];
  // Initialize troopOwned to include all possible troops
  let troopOwned = { 
  Goblins: 0, 
  Skeletons: 0, 
  Barbarians: 0, 
  Wizards: 0, 
  Valkyrie: 0, 
  'Mini Pekka': 0, 
  Knights: 0, 
  'Ice Golem': 0, 
  'Dart Goblin': 0, 
  'Hog Riders': 0 
};

let deployedTroops = { 
  Goblins: 0, 
  Skeletons: 0, 
  Barbarians: 0, 
  Wizards: 0, 
  Valkyrie: 0, 
  'Mini Pekka': 0, 
  Knights: 0, 
  'Ice Golem': 0, 
  'Dart Goblin': 0, 
  'Hog Riders': 0 
};

  // Battle state
  let battleInProgress = false; // <-- Add this flag

  // Add to game state section
  let skeletons = 0;
  let criticalHitChance = 0;

  // Initialize battle cost
let battleCost = 500;

// Add these to your existing game state variables
let chestFindChance = 0;
let defeatAvoidanceChance = 0;
let instantWinChance = 0;
let trophyGainBonus = 0;
let trophyLossReduction = 0;
let goldHoardChance = 0;
let passiveGoldMultiplier = 1;

// Game loop for passive gold generation
  setInterval(() => {
    if (!battleInProgress) {
      gold += goldPerSec;
      goldSpan.textContent = Math.floor(gold);
    }
  }, 1000);

  function updateDisplay() {
    // Calculate passive gold generation with bonuses
    let baseGoldPerSec = elixirCollectors * 1;
    
    // Apply Wizard bonus (+1% per wizard)
    const wizardCount = troopOwned.Wizards || 0;
    passiveGoldMultiplier = 1 + (wizardCount * 0.01);
    
    // Apply meta bonuses
    const metaGoldBonus = 1 + (metaUpgrades.goldenTouch * 0.05);
    
    goldPerSec = Math.floor(baseGoldPerSec * passiveGoldMultiplier * metaGoldBonus);

    // Update display elements
    trophiesSpan.textContent = trophies;
    goldSpan.textContent = Math.floor(gold);
    goldPerSecSpan.textContent = goldPerSec;
    elixirCountSpan.textContent = elixirCollectors;
    goblinCountSpan.textContent = goblins;

    // Calculate current mine gold value with Goblin bonus
    let bonus = 1 + goblins * 0.05;
    let mineGoldValue = mineGoldBase * bonus;
    mineGoldBtn.textContent = `Mine Gold (+${mineGoldValue.toFixed(2)})`;

    // Update battle button cost with strategy modifier
    const strategyCost = Math.floor(battleCost * strategies[currentStrategy].battleCost);
    battleBtn.textContent = `Battle! (Cost: ${strategyCost} gold)`;

    // Update troop bonuses
    updateTroopBonuses();

    // Update troop controls (existing slider code)
    if (troopListDiv.children.length !== troopTypes.length) {
      troopListDiv.innerHTML = '';
      troopTypes.forEach(type => {
        const div = document.createElement('div');
        div.className = 'troop-slider-container';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.className = 'troop-slider';
        slider.min = '0';
        slider.max = troopOwned[type];
        slider.step = '1';
        slider.value = deployedTroops[type];
        
        slider.addEventListener('input', (e) => {
          deployedTroops[type] = parseInt(e.target.value);
          div.querySelector('.troop-count').textContent = deployedTroops[type];
          
          let totalTroops = troopTypes.reduce((sum, t) => sum + deployedTroops[t], 0);
          let winChance = Math.min(99, 50 + (totalTroops * 0.1) + (metaUpgrades.battleMaster * 2));
          winChanceSpan.textContent = Math.floor(winChance);
        });
        
        div.innerHTML = `
          <span class="troop-info">${type} (${troopOwned[type]})</span>
          <span class="troop-count">${deployedTroops[type]}</span>
        `;
        
        div.insertBefore(slider, div.querySelector('.troop-count'));
        troopListDiv.appendChild(div);
      });
    } else {
      troopTypes.forEach((type, index) => {
        const container = troopListDiv.children[index];
        const slider = container.querySelector('.troop-slider');
        const info = container.querySelector('.troop-info');
        const count = container.querySelector('.troop-count');
        
        slider.max = troopOwned[type];
        slider.value = deployedTroops[type];
        info.textContent = `${type} (${troopOwned[type]})`;
        count.textContent = deployedTroops[type];
      });
    }

    // Win chance calculation with bonuses
    let totalTroops = troopTypes.reduce((sum, t) => sum + deployedTroops[t], 0);
    let winChance = Math.min(99, 50 + (totalTroops * 0.1) + (metaUpgrades.battleMaster * 2));
    winChanceSpan.textContent = Math.floor(winChance);

    battleBtn.disabled = gold < strategyCost || battleInProgress;

    // Update skeleton count and critical hit chance
    const skeletonCountSpan = document.getElementById('skeletonCount');
    if (skeletonCountSpan) {
      skeletonCountSpan.textContent = skeletons;
    }
    criticalHitChance = skeletons * 0.2; // Updated to 0.2% per skeleton

    checkArenaUpgrade();
  }

  function updateTroopBonuses() {
  // Update all troop-based bonuses
  chestFindChance = (troopOwned.Valkyrie || 0) * 0.3;
  defeatAvoidanceChance = (troopOwned.Barbarians || 0) * 0.3;
  instantWinChance = (troopOwned['Mini Pekka'] || 0) * 0.2;
  trophyGainBonus = (troopOwned.Knights || 0) * 1; // +1 trophy per knight
  trophyLossReduction = (troopOwned['Ice Golem'] || 0) * 1; // -1 trophy loss per ice golem
  goldHoardChance = (troopOwned['Hog Riders'] || 0) * 0.1;
  
  // Dart Goblin bonus is already applied in updateDisplay via passiveGoldMultiplier
}

  // Troop deployment controls
  window.changeTroop = function(type, delta) {
    if (delta === 1 && deployedTroops[type] < troopOwned[type]) {
      deployedTroops[type]++;
    } else if (delta === -1 && deployedTroops[type] > 0) {
      deployedTroops[type]--;
    }
    updateDisplay();
  };

  // Add this new function for slider updates
window.updateDeployedTroops = function(type, value) {
  deployedTroops[type] = parseInt(value);
  updateDisplay();
};

  // Battle logic
  function showBattleProgress(callback) {
    battleInProgress = true; // <-- Set flag
    updateDisplay();         // <-- Update button state

    // Make button unclickable and show countdown
    battleBtn.disabled = true;
    let originalText = battleBtn.textContent;
    let secondsLeft = 10;
    battleBtn.textContent = `Battling (${secondsLeft}s)`;

    // Create a flex container for battleBtn and progressBar if not already present
    if (!battleBtn.parentNode.classList.contains('battle-flex')) {
      const flexDiv = document.createElement('div');
      flexDiv.className = 'battle-flex';
      flexDiv.style.display = 'flex';
      flexDiv.style.alignItems = 'center';
      // Move battleBtn into flexDiv
      battleBtn.parentNode.insertBefore(flexDiv, battleBtn);
      flexDiv.appendChild(battleBtn);
    }
    const flexDiv = battleBtn.parentNode;

    // Remove any existing progress bar
    const oldBar = document.getElementById('battleProgressBar');
    if (oldBar) oldBar.remove();

    // Create progress bar with same height as button, width 120px
    const progressBar = document.createElement('div');
    progressBar.id = 'battleProgressBar';
    progressBar.style.width = '120px';
    progressBar.style.height = `${battleBtn.offsetHeight}px`;
    progressBar.style.background = '#22304a';
    progressBar.style.borderRadius = '8px';
    progressBar.style.marginLeft = '12px';
    progressBar.style.position = 'relative';
    progressBar.style.flexShrink = '0';

    const fill = document.createElement('div');
    fill.style.height = '100%';
    fill.style.width = '0%';
    fill.style.background = '#4caf50';
    fill.style.borderRadius = '8px';
    fill.style.transition = 'width 0.2s linear';
    progressBar.appendChild(fill);

    // Insert progress bar to the right of the button
    flexDiv.appendChild(progressBar);

    let elapsed = 0;
    const duration = 10; // seconds
    const interval = setInterval(() => {
      elapsed++;
      secondsLeft--;
      fill.style.width = `${(elapsed / duration) * 100}%`;
      battleBtn.textContent = `Battling (${secondsLeft}s)`;
      if (elapsed >= duration) {
        clearInterval(interval);
        progressBar.remove();
        battleBtn.textContent = originalText;
        battleInProgress = false; // <-- Reset flag
        updateDisplay();          // <-- Update button state
        callback();
      }
    }, 1000);
  }

  battleBtn.addEventListener('click', () => {
    const strategyCost = Math.floor(battleCost * strategies[currentStrategy].battleCost);
    if (gold < strategyCost || battleInProgress) return;
    
    gold -= strategyCost;
    battleBtn.disabled = true;
    
    showBattleProgress(() => {
      let totalTroops = troopTypes.reduce((sum, t) => sum + deployedTroops[t], 0);
      let winChance = Math.min(99, 50 + (totalTroops * 0.1) + (metaUpgrades.battleMaster * 2));
      
      // Check for Mini Pekka instant win
      let instantWin = Math.random() * 100 < instantWinChance;
      
      let win = instantWin || Math.random() * 100 < winChance;
      
      if (win) {
        // Victory logic
        let trophiesWon = 26 + Math.floor(Math.random() * 8);
        
        // Apply strategy modifier
        trophiesWon = Math.floor(trophiesWon * strategies[currentStrategy].trophyGain);
        
        // Apply Knight bonus (flat +1 per knight)
        trophiesWon += trophyGainBonus;
        
        // Apply meta trophy bonus
        trophiesWon = Math.floor(trophiesWon * (1 + (metaUpgrades.trophyMagnet * 0.1)));
        
        // Cap trophies at next arena threshold if requirements aren't met
        const nextArena = ARENAS[currentArena + 1];
        if (nextArena && trophies + trophiesWon > nextArena.trophies) {
          trophies = nextArena.trophies;
        } else {
          trophies += trophiesWon;
        }
        
        let message = `Victory! You won ${trophiesWon} trophies.`;
        
        if (instantWin) {
          message = `üí• MINI PEKKA INSTANT WIN! You won ${trophiesWon} trophies!`;
        }
        
        // Check for Valkyrie chest find
        if (Math.random() * 100 < chestFindChance) {
          const chestGold = Math.floor(strategyCost * (2 + Math.random() * 3)); // 2-5x battle cost
          gold += chestGold;
          message += `\nüéÅ Found a treasure chest! +${chestGold} gold!`;
        }
        
        // Check for Hog Rider gold hoard
        if (Math.random() * 100 < goldHoardChance) {
          const hoardGold = Math.floor(strategyCost * (5 + Math.random() * 10)); // 5-15x battle cost
          gold += hoardGold;
          message += `\nüí∞ Hog Riders found a gold hoard! +${hoardGold} gold!`;
        }
        
        alert(message);
        
      } else {
        // Defeat logic
        
        // Check for Barbarian defeat avoidance
        if (Math.random() * 100 < defeatAvoidanceChance) {
          alert(`üõ°Ô∏è Barbarians protected your army! No troops lost, but you still lose trophies.`);
          
          let trophiesLost = 20 + Math.floor(Math.random() * 8);
          trophiesLost = Math.max(1, trophiesLost - trophyLossReduction); // Ice Golem reduction
          trophies = Math.max(0, trophies - trophiesLost);
          
          alert(`Defeat! You lost ${trophiesLost} trophies, but your troops survived!`);
        } else {
          // Normal defeat with troop losses
          let trophiesLost = 20 + Math.floor(Math.random() * 8);
          trophiesLost = Math.max(1, trophiesLost - trophyLossReduction); // Ice Golem reduction
          trophies = Math.max(0, trophies - trophiesLost);
          
          // Calculate troop losses with strategy modifier
          const lossRate = strategies[currentStrategy].troopLoss * 0.3;
          let troopsLostMessage = "";
          
          troopTypes.forEach(type => {
            if (deployedTroops[type] > 0) {
              const troopsLost = Math.ceil(deployedTroops[type] * lossRate);
              troopOwned[type] = Math.max(0, troopOwned[type] - troopsLost);
              deployedTroops[type] = Math.max(0, deployedTroops[type] - troopsLost);
              
              // Update individual counters
              if (type === 'Goblins') {
                goblins = Math.max(0, goblins - troopsLost);
              }
              if (type === 'Skeletons') {
                skeletons = Math.max(0, skeletons - troopsLost);
              }
              
              if (troopsLost > 0) {
                troopsLostMessage += `${troopsLost} ${type}, `;
              }
            }
          });
          
          if (troopsLostMessage) {
            troopsLostMessage = troopsLostMessage.slice(0, -2);
            alert(`Defeat! You lost ${trophiesLost} trophies and ${troopsLostMessage}.`);
          } else {
            alert(`Defeat! You lost ${trophiesLost} trophies.`);
          }
        }
      }
      
      updateDisplay();
      checkArenaUpgrade();
    });
  });

  // Utility function to show floating cost text for any upgrade button
  function showFloatingCost(btn, amount) {
    const btnRect = btn.getBoundingClientRect();
    const parentRect = document.body.getBoundingClientRect();

    const floatText = document.createElement('span');
    floatText.innerHTML = `-${amount} <img src="img/coin.png" alt="coin" width="18" height="18" style="vertical-align:middle;">`;
    floatText.style.position = 'absolute';
    floatText.style.left = (btnRect.left - parentRect.left + btnRect.width/2 - 20 + Math.random()*20) + 'px';
    floatText.style.top = (btnRect.top - parentRect.top + btnRect.height/2 - 10 + Math.random()*10) + 'px';
    floatText.style.fontFamily = "'Supercell Magic', Arial, sans-serif";
    floatText.style.fontSize = '1.1em';
    floatText.style.fontWeight = 'bold';
    floatText.style.color = '#e74c3c';
    floatText.style.textShadow = '1px 1px 0 #2e3d53, 2px 2px 0 #b8860b';
    floatText.style.pointerEvents = 'none';
    floatText.style.opacity = '1';
    floatText.style.transition = 'transform 1s cubic-bezier(.4,2,.6,1), opacity 1s';

    document.body.appendChild(floatText);

    setTimeout(() => {
      floatText.style.transform = `translateY(-36px) scale(1.1)`;
      floatText.style.opacity = '0';
    }, 10);

    setTimeout(() => {
      floatText.remove();
    }, 1100);
  }

  // Buy Elixir Collector
  buyElixirBtn.addEventListener('click', () => {
    if (gold >= 50) {
      gold -= 50;
      elixirCollectors++;
      goldPerSec = elixirCollectors * 1;
      updateDisplay();
      showFloatingCost(buyElixirBtn, 50);
    }
  });

  // Buy Goblins
  buyGoblinBtn.addEventListener('click', () => {
    if (gold >= 100) {
      gold -= 100;
      goblins++;
      troopOwned.Goblins++;
      updateDisplay();
      showFloatingCost(buyGoblinBtn, 100);
    }
  });

  // Buy 10x Elixir Collectors
document.getElementById('buyElixirBtn10x').addEventListener('click', () => {
  if (gold >= 500) {
    gold -= 500;
    elixirCollectors += 10;
    goldPerSec = elixirCollectors * 1;
    updateDisplay();
    showFloatingCost(buyElixirBtn10x, 500);
  }
});

// Buy 10x Goblins
document.getElementById('buyGoblinBtn10x').addEventListener('click', () => {
  if (gold >= 1000) {
    gold -= 1000;
    goblins += 10;
    troopOwned.Goblins += 10;
    updateDisplay();
    showFloatingCost(buyGoblinBtn10x, 1000);
  }
});

// Modify the buyTroop function to handle 10x purchases
function buyTroop(troopType, cost, amount = 1) {
  const totalCost = cost * amount;
  if (gold >= totalCost) {
    gold -= totalCost;
    troopOwned[troopType] += amount;
    if (troopType === 'Skeletons') {
      skeletons += amount;
    }
    updateDisplay();
    
    // Update the specific troop counter display
    const countSpan = document.getElementById(`${troopType.toLowerCase()}Count`);
    if (countSpan) {
      countSpan.textContent = troopOwned[troopType];
    }
    
    // Only show floating cost if button exists
    const btn = document.getElementById(`buy${troopType}${amount > 1 ? '10x' : ''}Btn`);
    if (btn) {
      showFloatingCost(btn, totalCost);
    }
  }
}
    // Fix checkArenaUpgrade function
function checkArenaUpgrade() {
  const nextArena = ARENAS[currentArena + 1];
  const upgradeSection = document.querySelector('.upgrade-arena');
  const reqDisplay = document.getElementById('arenaUpgradeRequirements');
  const upgradeBtn = document.getElementById('upgradeArenaBtn');

  // If we're at the final arena, hide upgrade section permanently
  if (!nextArena) {
    upgradeSection.style.display = 'none';
    trophiesSpan.style.color = '#fff';
    
    // Show endgame content if we haven't already
    showEndgameContent();
    return;
  }

  // Check if we've hit trophy threshold
  if (trophies >= nextArena.trophies) {
    // Show upgrade section
    upgradeSection.style.display = 'block';
    
    // Check requirements
    const hasGold = gold >= nextArena.cost;
    const hasTroops = nextArena.troops.every(t => troopOwned[t.type] >= t.required);
    
    // Update requirements text
    let reqText = `Requirements for ${nextArena.name}:<br>`;
    reqText += `- ${nextArena.cost} Gold<br>`;
    nextArena.troops.forEach(t => {
      reqText += `- ${t.required} ${t.type}<br>`;
    });
    reqDisplay.innerHTML = reqText;

    // Enable/disable button based on requirements
    upgradeBtn.disabled = !(hasGold && hasTroops);

    // Highlight trophies if can't upgrade
    trophiesSpan.style.color = (!hasGold || !hasTroops) ? '#e74c3c' : '#fff';
  } else {
    upgradeSection.style.display = 'none';
    trophiesSpan.style.color = '#fff';
  }
}
window.buyTroop = buyTroop;

// Upgrade arena button click handler
document.getElementById('upgradeArenaBtn').addEventListener('click', () => {
  const nextArena = ARENAS[currentArena + 1];
  if (!nextArena) return;

  // Check requirements again for safety
  if (gold < nextArena.cost) return;
  for (const t of nextArena.troops) {
    if ((troopOwned[t.type] || 0) < t.required) return;
  }

  // Deduct costs
  gold -= nextArena.cost;
  nextArena.troops.forEach(t => {
    troopOwned[t.type] -= t.required;
    if (troopOwned[t.type] < 0) troopOwned[t.type] = 0;
    
    // Also update individual counters
    if (t.type === 'Goblins') {
      goblins -= t.required;
      if (goblins < 0) goblins = 0;
    }
    if (t.type === 'Skeletons') {
      skeletons -= t.required;
      if (skeletons < 0) skeletons = 0;
    }
    
    // Update the display counter for this troop type
    const countSpan = document.getElementById(`${t.type.toLowerCase()}Count`);
    if (countSpan) {
      countSpan.textContent = troopOwned[t.type];
    }
  });

  // Advance arena
  currentArena++;

  // Update battle cost when arena changes
  battleCost = 500 + (currentArena * 200);

  // Update arena title
  document.querySelector('h2').textContent = ARENAS[currentArena].name;

  // Unlock new troop if available
  if (nextArena.unlocks) {
    const newTroop = nextArena.unlocks;
    if (!unlockedTroops.includes(newTroop)) {
      unlockedTroops.push(newTroop);
      troopTypes.push(newTroop);
      troopOwned[newTroop] = 0;
      deployedTroops[newTroop] = 0;

      // Add new troop upgrade UI to the shop
      const upgradeSection = document.querySelector('.upgrade-section');
      const newUpgradeRow = document.createElement('div');
      newUpgradeRow.className = 'upgrade-row';

      // Define costs and descriptions for each troop
      const troopData = {
        'Skeletons': { cost: 150, description: '+0.2% critical hit chance when mining gold' },
        'Barbarians': { cost: 200, description: '+0.3% chance to avoid troop loss on defeat' },
        'Wizards': { cost: 300, description: '+1% passive gold generation speed' },
        'Valkyrie': { cost: 500, description: '+0.3% chance to find chest after winning battle' },
        'Mini Pekka': { cost: 750, description: '+0.2% chance to instantly win battles' },
        'Knights': { cost: 1000, description: '+1% trophy gain on victory' },
        'Ice Golem': { cost: 1500, description: '-1% trophy loss on defeat' },
        'Dart Goblin': { cost: 2000, description: '+2% something idk yet' },
        'Hog Riders': { cost: 3000, description: '+0.1% chance to find gold hoard after battle' }
      };

      const cost = troopData[newTroop].cost;
      const description = troopData[newTroop].description;

      newUpgradeRow.innerHTML = `
        <div class="upgrade-label">
          ${newTroop}
          <img src="img/info.png" alt="info" class="info-icon" onclick="showInfo(this, '${description}')">
        </div>
        <div class="button-group">
          <button id="buy${newTroop}Btn" onclick="buyTroop('${newTroop}', ${cost})">
            ${cost}
            <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
          </button>
          <button id="buy${newTroop}Btn10x" onclick="buyTroop('${newTroop}', ${cost}, 10)">
            ${cost * 10}
            <img src="img/coin.png" alt="coin" width="20" height="20" style="vertical-align:middle;">
            x10
          </button>
        </div>
        <span>${newTroop}: <span id="${newTroop.toLowerCase()}Count">0</span></span>
      `;
      upgradeSection.appendChild(newUpgradeRow);
    }
  }

  updateDisplay();
  checkArenaUpgrade();
  });
});

// Enhanced feedback system
function enhanceButton(button, type) {
  button.classList.add(type);
  setTimeout(() => {
    button.classList.remove(type);
  }, type === 'level-up' ? 3000 : 600);
}

function showBigNumber(element, value, color = '#4CAF50') {
  const bigText = document.createElement('div');
  bigText.textContent = `+${value}`;
  bigText.style.cssText = `
    position: absolute;
    font-size: 2.5em;
    font-weight: bold;
    color: ${color};
    pointer-events: none;
    z-index: 100;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    animation: bigNumberPop 2s ease-out forwards;
  `;
  
  const rect = element.getBoundingClientRect();
  bigText.style.left = (rect.left + rect.width/2 - 50) + 'px';
  bigText.style.top = (rect.top - 30) + 'px';
  
  document.body.appendChild(bigText);
  
  setTimeout(() => bigText.remove(), 2000);
}

// Strategy System
const strategies = {
  aggressive: { 
    name: "üó°Ô∏è Aggressive",
    battleCost: 0.8, 
    trophyGain: 1.2, 
    troopLoss: 1.3 
  },
  balanced: { 
    name: "‚öñÔ∏è Balanced",
    battleCost: 1.0, 
    trophyGain: 1.0, 
    troopLoss: 1.0 
  },
  defensive: { 
    name: "üõ°Ô∏è Defensive",
    battleCost: 1.2, 
    trophyGain: 0.8, 
    troopLoss: 0.7 
  }
};

window.setStrategy = function(strategy) {
  currentStrategy = strategy;
  
  // Update visual feedback
  document.querySelectorAll('.strategy-option').forEach(option => {
    option.classList.remove('active');
  });
  document.querySelector(`[data-strategy="${strategy}"]`).classList.add('active');
  
  document.getElementById('currentStrategy').textContent = strategies[strategy].name;
  updateDisplay();
};

// Initialize strategy display
document.querySelector('[data-strategy="balanced"]').classList.add('active');

// Infinite Arena System (after Hog Mountain)
function generateInfiniteArena(level) {
  return {
    name: `Legendary Arena ${level}`,
    trophies: 3000 + (level * 1000),
    cost: 200000 * Math.pow(1.5, level),
    troops: [{type: "Hog Riders", required: 100 + (level * 50)}],
    unlocks: null, // No new troops in infinite arenas
    rewards: {
      goldMultiplier: 1 + (level * 0.1),
      newFeatures: level % 5 === 0
    }
  };
}

let infiniteArenaLevel = 0;
let infiniteGoldMultiplier = 1.0;

// Modify checkArenaUpgrade to handle infinite progression
function checkArenaUpgradeInfinite() {
  let nextArena;
  
  if (currentArena < ARENAS.length - 1) {
    nextArena = ARENAS[currentArena + 1];
  } else {
    // Generate infinite arena
    infiniteArenaLevel = currentArena - (ARENAS.length - 1);
    nextArena = generateInfiniteArena(infiniteArenaLevel + 1);
  }
  
  const upgradeSection = document.querySelector('.upgrade-arena');
  const reqDisplay = document.getElementById('arenaUpgradeRequirements');
  const upgradeBtn = document.getElementById('upgradeArenaBtn');

  if (trophies >= nextArena.trophies) {
    upgradeSection.style.display = 'block';
    
    const hasGold = gold >= nextArena.cost;
    const hasTroops = nextArena.troops.every(t => troopOwned[t.type] >= t.required);
    
    let reqText = `Requirements for ${nextArena.name}:<br>`;
    reqText += `- ${nextArena.cost.toLocaleString()} Gold<br>`;
    nextArena.troops.forEach(t => {
      reqText += `- ${t.required} ${t.type}<br>`;
    });
    
    if (nextArena.rewards) {
      reqText += `<br><strong>Rewards:</strong><br>`;
      reqText += `- +${(nextArena.rewards.goldMultiplier - 1) * 100}% Gold Generation<br>`;
      if (nextArena.rewards.newFeatures) {
        reqText += `- New Special Feature!<br>`;
      }
    }
    
    reqDisplay.innerHTML = reqText;
    upgradeBtn.disabled = !(hasGold && hasTroops);
    trophiesSpan.style.color = (!hasGold || !hasTroops) ? '#e74c3c' : '#fff';
  } else {
    upgradeSection.style.display = 'none';
    trophiesSpan.style.color = '#fff';
  }
}

// Call this function in the appropriate place in your existing code
checkArenaUpgradeInfinite();

// Meta-progression system
let metaUpgrades = {
  goldenTouch: 0,
  battleMaster: 0,
  efficiency: 0,
  trophyMagnet: 0
};

// Load from localStorage
const savedMeta = localStorage.getItem('clashIdleMeta');
if (savedMeta) {
  metaUpgrades = JSON.parse(savedMeta);
}

function saveMeta() {
  localStorage.setItem('clashIdleMeta', JSON.stringify(metaUpgrades));
}

function updateMetaDisplay() {
  document.getElementById('goldenTouchLevel').textContent = metaUpgrades.goldenTouch;
  document.getElementById('battleMasterLevel').textContent = metaUpgrades.battleMaster;
  document.getElementById('efficiencyLevel').textContent = metaUpgrades.efficiency;
  document.getElementById('trophyMagnetLevel').textContent = metaUpgrades.trophyMagnet;
  
  // Update button costs
  const goldenTouchCost = 1000000 * Math.pow(2, metaUpgrades.goldenTouch);
  const battleMasterCost = 2500000 * Math.pow(1.8, metaUpgrades.battleMaster);
  const efficiencyCost = 5000000 * Math.pow(2.2, metaUpgrades.efficiency);
  const trophyMagnetCost = 10000000 * Math.pow(3, metaUpgrades.trophyMagnet);
  
  document.getElementById('buyGoldenTouch').textContent = 
    metaUpgrades.goldenTouch >= 10 ? 'MAX' : `${goldenTouchCost.toLocaleString()} Gold`;
  document.getElementById('buyBattleMaster').textContent = 
    metaUpgrades.battleMaster >= 20 ? 'MAX' : `${battleMasterCost.toLocaleString()} Gold`;
  document.getElementById('buyEfficiency').textContent = 
    metaUpgrades.efficiency >= 10 ? 'MAX' : `${efficiencyCost.toLocaleString()} Gold`;
  document.getElementById('buyTrophyMagnet').textContent = 
    metaUpgrades.trophyMagnet >= 5 ? 'MAX' : `${trophyMagnetCost.toLocaleString()} Gold`;
}

// Meta upgrade event listeners
document.getElementById('buyGoldenTouch').addEventListener('click', () => {
  const cost = 1000000 * Math.pow(2, metaUpgrades.goldenTouch);
  if (gold >= cost && metaUpgrades.goldenTouch < 10) {
    gold -= cost;
    metaUpgrades.goldenTouch++;
    saveMeta();
    updateMetaDisplay();
    updateDisplay();
    showBigNumber(document.getElementById('buyGoldenTouch'), '5% FOREVER!', '#9C27B0');
  }
});

// Apply meta bonuses to your existing calculations
function applyMetaBonuses() {
  // Apply to gold generation
  const metaGoldBonus = 1 + (metaUpgrades.goldenTouch * 0.05);
  goldPerSec = Math.floor(elixirCollectors * 1 * metaGoldBonus);
  
  // Apply efficiency bonus to costs (in buyTroop function)
  const metaEfficiency = 1 - Math.min(0.5, metaUpgrades.efficiency * 0.05);
  
  // Apply to battle win chance (in battle logic)
  const metaBattleBonus = metaUpgrades.battleMaster * 2;
  
  // Apply to trophy gains (in battle victory)
  const metaTrophyBonus = 1 + (metaUpgrades.trophyMagnet * 0.1);
}

function displayTroopBonuses() {
  // You can call this in updateDisplay() to show current bonuses
  const bonusText = [];

  if (chestFindChance > 0) bonusText.push(`üéÅ Chest Find: ${chestFindChance.toFixed(1)}%`);
  if (defeatAvoidanceChance > 0) bonusText.push(`üõ°Ô∏è Defeat Avoidance: ${defeatAvoidanceChance.toFixed(1)}%`);
  if (instantWinChance > 0) bonusText.push(`üí• Instant Win: ${instantWinChance.toFixed(1)}%`);
  if (trophyGainBonus > 0) bonusText.push(`üèÜ Trophy Bonus: +${trophyGainBonus}`);
  if (trophyLossReduction > 0) bonusText.push(`üõ°Ô∏è Trophy Protection: -${trophyLossReduction}`);
  if (goldHoardChance > 0) bonusText.push(`üí∞ Gold Hoard: ${goldHoardChance.toFixed(1)}%`);
  if (criticalHitChance > 0) bonusText.push(`üíÄ Critical Chance: ${criticalHitChance.toFixed(1)}%`);
  
  // You can display these bonuses somewhere in your UI if desired
  return bonusText;
}
